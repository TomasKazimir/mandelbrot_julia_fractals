import glob
import os
import time
from math import floor
from multiprocessing import Process

from PIL import Image, ImageDraw

from img_join import join_h


def point_mandel_func(c: complex, iter_limit: int):
    """
    For a complex number c returns the number of iterations needed to reach
    modulus bigger than 2 (distance from 0+0j)
    or the iter_limit
    """
    if abs(c) > 2:
        return 1
    z = 0
    n = 0
    while abs(z) <= 2 and n < iter_limit:
        z = z * z + c
        n += 1
    return n


def mandelbrot_img(
    iter_limit: int,
    res: tuple,
    pos: tuple = (0, 0),
    zoom: int = 0,
    bgc: tuple = (255, 255, 255),
    save_dir="temp_dir",
):
    X, Y = pos

    WIDTH, HEIGHT = res
    screen_ratio = WIDTH / HEIGHT

    RE_START = X - 2 * screen_ratio / 2 ** zoom
    RE_END = X + 2 * screen_ratio / 2 ** zoom
    IM_START = Y + 2 / 2 ** zoom
    IM_END = Y - 2 / 2 ** zoom

    im = Image.new("RGB", (WIDTH, HEIGHT), bgc)

    draw = ImageDraw.Draw(im)

    for x in range(0, WIDTH):
        for y in range(0, HEIGHT):

            c = complex(
                RE_START + (x / WIDTH) * (RE_END - RE_START),
                IM_START + (y / HEIGHT) * (IM_END - IM_START),
            )

            iter_reached = point_mandel_func(c, iter_limit)

            point_color = tuple(
                int(
                    iter_reached * (color / iter_limit)
                )  # if iter_reached < iter_limit else 255 - color)
                for color in bgc
            )

            draw.point([x, y], point_color)

    im.save(f"{save_dir}x{X},y{Y,}z{zoom},i{iter_limit}.png", "PNG")


def multiproc_mandelbrot(
    p_count: int,
    iter_limit: int,
    res: tuple,
    pos: tuple,
    zoom: float,
    bgc: tuple,
    save_dir="output_dir",
    temp_dir="temp_dir",
):
    """
    generates specified part of the mandelbrot set using multiprocessing
    (p_count should not be bigger than your number of logical processors)
    """
    if (
        res[0] * res[1] / p_count > 178956970
    ):  # PIL can not load images with more than 178956970 pixels
        print("Resolution too high, PIL won't handle it!")
        print(f"Resolution: {res[0]}x{res[1]}")
        print(
            f"Limit exceeded by {int(res[0] * res[1] / p_count - 178_956_970)} pixels."
        )
        print(
            f"Try {res[0]}x{int(res[1] - (res[0] * res[1] / p_count - 178956970)/res[0]*p_count)}"
        )
        return

    # create dir where we want to save the output img if it doesnt exist
    if not os.path.exists(save_dir):
        os.mkdir(save_dir)

    # create temporary dir for processes outputs if it doesnt exist
    if not os.path.exists(temp_dir):
        os.mkdir(temp_dir)
    else:  # delete all files in temp dir if it has already existed
        files = glob.glob(f"{temp_dir}/*")
        if len(files) > 0:
            if (
                input(
                    "These files:\n"
                    + "\n".join(files)
                    + f"\nfrom {temp_dir} directory will be deleted. [Y/N?] "
                )
                != "Y"
            ):
                return
            for f in files:
                os.remove(f)

    # we generate the fractal in smaller chunks using multiprocessing module to utilize more cpu (up to 100%)
    # (if p_count is to high, your PC may struggle)
    r = res[0] / res[1]  # used for calculating the pos argument for each process
    processes = [
        Process(
            target=mandelbrot_img,
            args=(
                iter_limit,
                (res[0] // p_count, res[1]),
                (
                    pos[0]
                    - 2 / (2 ** zoom) * r
                    + (  # callulating the pos argument is complicated, but it works :)
                        2 / ((2 ** zoom) * p_count)
                    )
                    * (2 * i + 1)
                    * r,
                    pos[1],
                ),
                zoom,
                bgc,
                temp_dir + "/" + "0" * (len(str(p_count)) - len(str(i))) + str(i),
            ),
        )
        for i in range(p_count)
    ]

    t = time.time()
    print(f"Mandelbrot Set - xy:{pos}, z:{zoom}, i:{iter_limit}, r:{res}")
    print(
        f"--- Starting {p_count} processes - "
        f'{time.strftime("%H:%M:%S", time.localtime())} ---'
    )
    for p in processes:  # starting all processes
        p.start()
        # print(f'{p.name}\tPID-{p.pid}\tstarted')

    print(
        f"--- Joining {p_count} processes - "
        f'{time.strftime("%H:%M:%S", time.localtime())} ---'
    )
    for p in processes:  # joining all processes (= waiting for them to finish)
        p.join()
        print(f"{p.name}\tPID-{p.pid}\tjoined")

    # load images generated by processes
    images = [Image.open(temp_dir + "/" + path) for path in os.listdir(temp_dir)]

    # joining images into output image and saving that in save_dir with informations as its name
    im = join_h(*images)
    im.save(
        f"{save_dir}/x{pos[0]},y{pos[1]},z{round(zoom, 2)},i{iter_limit},r{res}.png",
        "PNG",
    )

    t = time.time() - t  # how much time it took to generate
    print(
        f"--- Finished in "
        f"{int(t/60)} m "
        f"{floor(t%60)} s "
        f"{round(t%60%1*100)} ms ---"
    )
    print()

    # deleting the previously created temp dir
    files = glob.glob(f"{temp_dir}/*")
    for f in files:
        os.remove(f)
    os.rmdir(temp_dir)


if __name__ == "__main__":
    # print(multiprocessing.cpu_count())

    # initial settings
    p_count = 12
    iter_limit = 75
    res: tuple = (1280 * 3, 720 * 3)
    pos: tuple = (-1.5, 0)
    zoom = 1
    bgc: tuple = (255, 255, 255)
    save_dir = "save_dir_001"

    frames_count = 10
    iter_plus = 25
    zoom_plus = 1

    while frames_count > 0:
        multiproc_mandelbrot(
            p_count, iter_limit, res, pos, zoom, bgc, save_dir=save_dir
        )
        iter_limit += iter_plus
        zoom += zoom_plus
        frames_count -= 1

    print("Done!")
